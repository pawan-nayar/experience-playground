<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beyond Dictionary: Synonym Finder</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base Styles: Ensure full viewport coverage and no scrollbars */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent ALL scrolling */
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f8ff, #e0f2f7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            box-sizing: border-box; /* Include padding/border in element's total width/height */
        }

        /* Game Container: Maximize playable area within viewport */
        .game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px; /* Consistent internal padding */
            width: 96vw; /* Responsive width */
            height: 96vh; /* Responsive height */
            max-width: 950px; /* Max size for larger screens */
            max-height: 950px;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Distribute content vertically */
            align-items: center;
            position: relative; /* For modals/effects */
            overflow: hidden; /* Crucial to contain all internal elements */
            box-sizing: border-box;
        }

        /* Welcome Screen */
        #welcome-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            text-align: center;
        }

        #welcome-screen h1 {
            font-size: clamp(2em, 5vw, 3.5em); /* Responsive font size */
            color: #0056b3;
            margin-bottom: 20px;
            font-weight: 700;
        }

        #welcome-screen p {
            font-size: clamp(0.9em, 2.5vw, 1.2em); /* Responsive font size */
            color: #555;
            margin-bottom: 40px;
            max-width: 600px;
            line-height: 1.6;
        }

        .button {
            background-color: #007bff;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 30px;
            font-size: clamp(1em, 2.5vw, 1.2em);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.3);
            text-decoration: none;
        }

        .button:hover {
            background-color: #0056b3;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        /* Main Game Screen */
        #game-screen {
            display: none; /* Hidden by default */
            width: 100%;
            height: 100%;
            flex-direction: column;
            justify-content: space-between; /* Space out sections */
            align-items: center;
            box-sizing: border-box;
        }

        /* Top Tray */
        .top-tray {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background-color: #f8f9fa;
            padding: 10px 20px; /* Compressed padding */
            border-radius: 12px;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 15px; /* Minimal margin */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .top-tray div {
            font-size: clamp(0.9em, 2vw, 1.2em);
            font-weight: 600;
            color: #007bff;
            display: flex;
            align-items: center;
        }

        .top-tray span {
            margin-left: 8px;
            color: #333;
        }
        .top-tray #timer-display {
            color: #dc3545;
        }

        /* Letter Fall Area */
        .letter-fall-area {
            display: flex;
            justify-content: space-around; /* Distribute columns evenly */
            width: 100%;
            height: 55%; /* Takes significant portion of game screen height */
            background-color: #e9ecef;
            border-radius: 15px;
            overflow: hidden; /* Crucial: letters are positioned absolutely within this */
            position: relative;
            flex-grow: 1; /* Allows it to take available space */
            margin-bottom: 15px; /* Minimal margin */
            border: 1px solid #dee2e6;
        }

        .letter-column {
            flex: 1; /* Each column takes equal horizontal width */
            position: relative; /* Context for absolutely positioned tiles */
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            height: 100%; /* Ensure column fills fall area height */
        }
        .letter-column:last-child {
            border-right: none;
        }

        .letter-tile {
            width: 50px; /* Fixed size for consistency */
            height: 50px;
            background-color: #cce5ff;
            color: #0056b3;
            font-size: 2em;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            cursor: grab;
            user-select: none;
            position: absolute; /* Controlled by JS for precise falling */
            left: 50%; /* Center horizontally within its column */
            transform: translateX(-50%); /* Adjust for left:50% */
            opacity: 1; /* Always visible */
            z-index: 10;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            will-change: top; /* Optimize for 'top' property animation */
        }

        .letter-tile:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .letter-tile.dragging {
            opacity: 0.7;
            transform: translateX(-50%) scale(1.1);
        }

        /* Prompt Area */
        .prompt-area {
            width: 100%;
            margin-bottom: 15px; /* Minimal margin */
            flex-shrink: 0;
        }

        .prompt-area p {
            font-size: clamp(1em, 2.5vw, 1.3em);
            color: #333;
            margin-bottom: 10px;
        }

        .drop-zone-container {
            display: flex;
            justify-content: center;
            gap: 8px; /* Space between drop boxes */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            padding: 5px 0; /* Small vertical padding to prevent cutting on wrap */
        }

        .drop-zone {
            width: 55px;
            height: 55px;
            background-color: #f0f0f0;
            border: 2px dashed #ccc;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            color: #666;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0; /* Prevent shrinking on wrap */
        }

        .drop-zone.hovered {
            background-color: #e0e0e0;
            border-color: #007bff;
            transform: scale(1.05);
        }

        /* Feedback colors */
        .drop-zone.correct {
            background-color: #d4edda;
            border-color: #28a745;
            color: #28a745;
        }
        .drop-zone.wrong-position {
            background-color: #fff3cd;
            border-color: #ffc107;
            color: #ffc107;
        }
        .drop-zone.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #dc3545;
        }
        /* Style for pre-filled hint cell */
        .drop-zone.hint-cell {
            background-color: #e6f7ff;
            border-color: #4da6ff;
            color: #007bff;
            box-shadow: inset 0 2px 5px rgba(0, 123, 255, 0.15);
            cursor: default; /* Hint cells are not draggable or droppable on */
        }


        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 15px; /* Minimal margin */
            flex-shrink: 0;
            justify-content: center;
            width: 100%;
        }

        .controls .button {
            padding: 10px 20px;
            font-size: clamp(0.9em, 2vw, 1em);
        }

        /* Footer */
        .footer {
            margin-top: auto; /* Push to bottom */
            padding-top: 10px; /* Compressed padding */
            font-size: clamp(0.7em, 1.5vw, 0.8em);
            color: #777;
            border-top: 1px solid #eee;
            width: 100%;
            flex-shrink: 0;
            text-align: center;
        }

        /* Confetti Effect (Simple Glow) */
        .confetti-glow {
            animation: glow 1s ease-in-out forwards;
            box-shadow: 0 0 30px rgba(40, 167, 69, 0.6);
        }

        @keyframes glow {
            0% { box-shadow: 0 0 0px rgba(40, 167, 69, 0); }
            50% { box-shadow: 0 0 30px rgba(40, 167, 69, 0.6); }
            100% { box-shadow: 0 0 0px rgba(40, 167, 69, 0); }
        }

        /* Game Over / Message Modal */
        #game-message-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            transform: translateY(-20px);
            opacity: 0;
            animation: slideIn 0.3s forwards;
        }

        @keyframes slideIn {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            font-size: clamp(1.5em, 4vw, 2.2em);
            color: #007bff;
            margin-bottom: 15px;
        }

        .modal-content p {
            font-size: clamp(1em, 2.5vw, 1.2em);
            color: #555;
            margin-bottom: 25px;
        }

        .modal-content .button {
            padding: 10px 25px;
            font-size: clamp(0.9em, 2vw, 1.1em);
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
                border-radius: 10px;
            }

            .top-tray {
                padding: 8px 15px;
                margin-bottom: 10px;
            }

            .letter-fall-area {
                margin-bottom: 10px;
            }

            .letter-tile {
                width: 45px;
                height: 45px;
                font-size: 1.8em;
            }

            .prompt-area {
                margin-bottom: 10px;
            }

            .drop-zone {
                width: 50px;
                height: 50px;
                font-size: 1.8em;
            }

            .drop-zone-container {
                gap: 6px;
            }

            .controls {
                margin-top: 10px;
                gap: 10px;
                flex-wrap: wrap; /* Allow buttons to wrap */
            }

            .footer {
                padding-top: 8px;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 5px;
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }

            #welcome-screen h1 {
                font-size: 1.8em;
            }

            #welcome-screen p {
                font-size: 0.85em;
            }

            .button {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            .top-tray {
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
                padding: 5px 10px;
            }

            .top-tray div {
                font-size: 0.8em;
            }

            .letter-fall-area {
                height: 50%; /* Adjusted for very small screens */
                min-height: 120px;
            }

            .letter-tile {
                width: 40px;
                height: 40px;
                font-size: 1.5em;
            }

            .drop-zone {
                width: 40px;
                height: 40px;
                font-size: 1.5em;
                border-radius: 8px;
            }

            .drop-zone-container {
                gap: 4px;
            }

            .prompt-area p {
                font-size: 0.9em;
            }

            .controls {
                flex-direction: column;
                gap: 8px;
            }
            .controls .button {
                width: 90%; /* Make buttons full width */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Screen 1: Welcome -->
        <div id="welcome-screen">
            <h1>Beyond Dictionary: Synonym Finder</h1>
            <p>
                Embark on an exciting linguistic adventure! "Beyond Dictionary: Synonym Finder" is an engaging educational game designed for English learners of all ages. Drag and drop falling letters to uncover the perfect synonym for the given word, expand your vocabulary, and master the art of word association. Get ready to learn and have fun!
            </p>
            <button class="button" id="begin-learning-button">Begin Learning</button>
        </div>

        <!-- Screen 2: Main Game -->
        <div id="game-screen">
            <!-- Top Tray -->
            <div class="top-tray">
                <div>Round: <span id="round-display">1/20</span></div>
                <div>Score: <span id="score-display">0</span></div>
                <div>‚è∞ Timer: <span id="timer-display">05:00</span></div>
            </div>

            <!-- Letter Fall Area -->
            <div class="letter-fall-area">
                <div class="letter-column" id="column-0"></div>
                <div class="letter-column" id="column-1"></div>
                <div class="letter-column" id="column-2"></div>
            </div>

            <!-- Prompt Area -->
            <div class="prompt-area">
                <p>What is the synonym of <strong><span id="base-word-display"></span></strong>?</p>
                <div class="drop-zone-container" id="drop-zone-container">
                    <!-- Drop zones will be dynamically generated here -->
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="button" id="next-button">Next Word</button>
                <button class="button" id="skip-button">Skip Word</button>
            </div>

            <!-- Footer -->
            <div class="footer">
                @ Beyond Dictionary, 2025
            </div>
        </div>

        <!-- Game Over / Message Modal -->
        <div id="game-message-modal">
            <div class="modal-content">
                <h2 id="modal-title"></h2>
                <p id="modal-message"></p>
                <button class="button" id="modal-close-button">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- Game Data ---
        // Updated wordData to ensure synonyms are max 8 letters
        const wordData = [
            { base: "radiant", synonym: "bright" }, // 6 letters
            { base: "happy", synonym: "joyful" },    // Changed to joyful (6 letters)
            { base: "sad", synonym: "gloomy" },      // Changed to gloomy (6 letters)
            { base: "strong", synonym: "mighty" },   // Changed to mighty (6 letters)
            { base: "quick", synonym: "rapid" },     // Changed to rapid (5 letters)
            { base: "smart", synonym: "clever" },    // 6 letters
            { base: "bright", synonym: "luminous" }, // Changed to luminous (8 letters)
            { base: "kind", synonym: "gentle" },     // Changed to gentle (6 letters)
            { base: "small", synonym: "tiny" },      // 4 letters
            { base: "big", synonym: "large" }        // Changed to large (5 letters)
        ];

        // --- Game State Variables ---
        let currentRound = 0;
        let score = 0;
        let timeLeft = 300; // 5 minutes in seconds
        let timerInterval;
        let letterSpawnInterval; // Interval for spawning new letters
        let currentWordIndex;
        let currentSynonymLetters = [];
        let droppedLetters = [];
        let droppedLetterOriginalIds = []; // Stores the ID of the original falling tile dropped
        let draggableLetterPool = []; // Letters available to fall
        let activeFallingTiles = new Set(); // Stores references to currently falling DOM elements
        let fallingTilePositions = {}; // Tracks {tileId: {top: x, column: y}} for precise movement

        // --- DOM Elements ---
        const welcomeScreen = document.getElementById('welcome-screen');
        const gameScreen = document.getElementById('game-screen');
        const beginLearningButton = document.getElementById('begin-learning-button');

        const roundDisplay = document.getElementById('round-display');
        const scoreDisplay = document.getElementById('score-display');
        const timerDisplay = document.getElementById('timer-display');
        const baseWordDisplay = document.getElementById('base-word-display');
        const dropZoneContainer = document.getElementById('drop-zone-container');
        const letterFallColumns = [
            document.getElementById('column-0'),
            document.getElementById('column-1'),
            document.getElementById('column-2')
        ];
        const nextButton = document.getElementById('next-button');
        const skipButton = document.getElementById('skip-button');

        const gameMessageModal = document.getElementById('game-message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseButton = document.getElementById('modal-close-button');

        // --- Audio for Speech Synthesis ---
        const synth = window.speechSynthesis;

        /**
         * Speaks the given text using the Web Speech API.
         * @param {string} text - The text to speak.
         */
        function speak(text) {
            if (synth && synth.speaking) {
                synth.cancel();
            }
            if (synth) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 0.8;
                synth.speak(utterance);
            } else {
                console.warn("Speech synthesis not supported.");
            }
        }

        /**
         * Updates the score display.
         * @param {number} points - Points to add or subtract.
         */
        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = score;
        }

        /**
         * Formats time from seconds into MM:SS.
         * @param {number} seconds - Time in seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        /**
         * Generates a pool of letters for falling, including synonym letters and distractors.
         * Ensures enough correct letters are available.
         * @param {string} synonym - The correct synonym.
         * @param {string[]} excludeChars - Characters to exclude from the pool (e.g., pre-filled hint).
         * @returns {string[]} Shuffled array of letters.
         */
        function generateLetterPool(synonym, excludeChars = []) {
            let pool = [];
            const synonymChars = synonym.toUpperCase().split('');
            const availableSynonymChars = synonymChars.filter(char => !excludeChars.includes(char));

            // Ensure ample correct letters are in the pool
            for (let i = 0; i < 3; i++) { // Add correct letters 3 times
                pool.push(...availableSynonymChars);
            }

            // Add distractors (random letters)
            const numDistractors = 10;
            for (let i = 0; i < numDistractors; i++) {
                const randomChar = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                pool.push(randomChar);
            }

            // Shuffle the entire pool thoroughly
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            return pool;
        }

        /**
         * Clears all falling letters and stops the animation loop.
         */
        function clearFallingLetters() {
            if (letterSpawnInterval) {
                clearInterval(letterSpawnInterval);
            }
            // Remove all active falling tiles from DOM and tracking
            activeFallingTiles.forEach(tile => {
                if (tile.parentNode) {
                    tile.parentNode.removeChild(tile);
                }
            });
            activeFallingTiles.clear();
            fallingTilePositions = {}; // Clear positions
            letterFallColumns.forEach(column => {
                column.innerHTML = ''; // Ensure columns are truly empty
            });
            draggableLetterPool = [];
            columnSpawnSequenceIndex = 0; // Reset spawn pattern index
        }

        // --- Letter Falling Animation Logic ---
        const LETTER_VISUAL_HEIGHT = 55; // Approx height + margin to prevent overlap
        // Calculate FALL_SPEED_PX_PER_SEC dynamically based on the actual height of the fall area
        let FALL_SPEED_PX_PER_SEC = 0; // Will be set in startRound

        let lastFrameTime = 0;
        let columnLastOccupiedTop = [0, 0, 0]; // Tracks the lowest point occupied in each column
        let columnSpawnSequenceIndex = 0; // Tracks the current step in the spawn pattern

        // Spawning pattern: middle -> (left, right) -> middle ...
        const spawnColumnsPerStep = [[1], [0, 2]];

        /**
         * Spawns a single letter tile into the DOM and initializes its falling animation.
         * @param {number} columnIndex - The column to spawn into (0, 1, 2).
         * @param {string} letter - The character for the tile.
         */
        function spawnSingleLetter(columnIndex, letter) {
            const tile = document.createElement('div');
            tile.classList.add('letter-tile');
            tile.textContent = letter;
            tile.setAttribute('draggable', 'true');
            tile.id = `falling-letter-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

            const column = letterFallColumns[columnIndex];

            // Position the tile
            tile.style.top = `0px`; // Start at the top of its column
            tile.style.left = `50%`;
            tile.style.transform = `translateX(-50%)`; // Keep centered

            column.appendChild(tile);
            activeFallingTiles.add(tile);
            fallingTilePositions[tile.id] = { top: 0, column: columnIndex, element: tile };

            // Add drag event listeners
            tile.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', tile.textContent);
                e.dataTransfer.setData('text/tile-id', tile.id);
                tile.classList.add('dragging');
                // Immediately remove the original tile from the falling area when dragged
                setTimeout(() => {
                    if (tile.parentNode) {
                        tile.parentNode.removeChild(tile);
                    }
                    activeFallingTiles.delete(tile);
                    delete fallingTilePositions[tile.id];
                }, 0);
            });
        }

        /**
         * Animation loop to update falling letter positions.
         * @param {DOMHighResTimeStamp} currentTime - Current time provided by requestAnimationFrame.
         */
        function animateFallingLetters(currentTime) {
            if (!lastFrameTime) lastFrameTime = currentTime;
            const deltaTime = (currentTime - lastFrameTime) / 1000; // time in seconds
            lastFrameTime = currentTime;

            const fallAreaHeight = letterFallColumns[0].offsetHeight; // Height of one column

            // Update positions of all active falling tiles
            activeFallingTiles.forEach(tile => {
                const tileData = fallingTilePositions[tile.id];
                if (!tileData) return; // Skip if somehow removed

                tileData.top += FALL_SPEED_PX_PER_SEC * deltaTime;
                tile.style.top = `${tileData.top}px`;

                // Remove tile if it falls completely out of view
                if (tileData.top > fallAreaHeight + LETTER_VISUAL_HEIGHT) {
                    if (tile.parentNode) {
                        tile.parentNode.removeChild(tile);
                    }
                    activeFallingTiles.delete(tile);
                    delete fallingTilePositions[tile.id];
                }
            });

            // Schedule next frame
            if (activeFallingTiles.size > 0 || letterSpawnInterval) { // Continue if letters are falling or spawning
                requestAnimationFrame(animateFallingLetters);
            }
        }

        /**
         * Manages spawning letters at intervals and ensures no overlap.
         */
        function startLetterSpawningManager() {
            clearFallingLetters(); // Stop any existing spawning and clean up

            const synonym = wordData[currentWordIndex].synonym;
            const prefilledChar = randomHintIndex !== -1 ? currentSynonymLetters[randomHintIndex] : null; // Get the hint char if it exists
            draggableLetterPool = generateLetterPool(synonym, prefilledChar ? [prefilledChar] : []);

            // Reset column last occupied top for fresh start
            columnLastOccupiedTop = letterFallColumns.map(() => 0);

            // Start the continuous spawn interval
            letterSpawnInterval = setInterval(() => {
                // Determine which columns to spawn into based on pattern
                const columnsToSpawn = spawnColumnsPerStep[columnSpawnSequenceIndex];
                columnSpawnSequenceIndex = (columnSpawnSequenceIndex + 1) % spawnColumnsPerStep.length;

                // For each column in this step:
                columnsToSpawn.forEach(colIndex => {
                    if (draggableLetterPool.length === 0) {
                        draggableLetterPool = generateLetterPool(synonym); // Regenerate pool
                    }
                    const letterToSpawn = draggableLetterPool.shift();
                    if (!letterToSpawn) return; // Should not happen

                    spawnSingleLetter(colIndex, letterToSpawn);
                });
            }, 1000); // Spawn a new set of letters every 1 second

            requestAnimationFrame(animateFallingLetters); // Start the animation loop
        }


        // --- Drag & Drop Handlers ---
        /**
         * Handles dragover event for drop zones.
         */
        function handleDragOver(e) {
            e.preventDefault();
            const dropZone = e.currentTarget;
            if (!dropZone.classList.contains('hint-cell')) {
                dropZone.classList.add('hovered');
            }
        }

        /**
         * Handles dragleave event for drop zones.
         */
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('hovered');
        }

        /**
         * Handles drop event for drop zones.
         */
        function handleDrop(e) {
            e.preventDefault();
            const dropZone = e.currentTarget;
            dropZone.classList.remove('hovered');

            if (dropZone.classList.contains('hint-cell')) {
                speak("This cell is a hint and cannot be changed.");
                return;
            }

            const letter = e.dataTransfer.getData('text/plain').toUpperCase();
            const dropIndex = parseInt(dropZone.dataset.index);

            // If a letter already exists in this drop zone, return it to the draggable pool
            if (droppedLetters[dropIndex]) {
                const oldLetterCharacter = droppedLetters[dropIndex];
                draggableLetterPool.push(oldLetterCharacter);
            }

            dropZone.textContent = letter;
            droppedLetters[dropIndex] = letter;

            checkLetterFeedback(letter, dropIndex);
            checkFullWordMatch();
        }

        /**
         * Checks feedback for a dropped letter.
         */
        function checkLetterFeedback(letter, index) {
            const dropZone = dropZoneContainer.children[index];
            const synonymLetter = currentSynonymLetters[index];

            dropZone.classList.remove('correct', 'wrong-position', 'incorrect');

            if (letter === synonymLetter) {
                dropZone.classList.add('correct');
                updateScore(10);
                speak("Great!");
            } else if (currentSynonymLetters.includes(letter)) {
                dropZone.classList.add('wrong-position');
                updateScore(4);
                speak("Close!");
            } else {
                dropZone.classList.add('incorrect');
                updateScore(-8);
                speak("Oops!");
            }
        }

        /**
         * Checks if the full synonym is matched.
         */
        function checkFullWordMatch() {
            const currentGuess = droppedLetters.join('');
            const correctSynonym = currentSynonymLetters.join('');

            // Only proceed if all drop zones are filled
            if (currentGuess.length === correctSynonym.length && !droppedLetters.includes('')) {
                if (currentGuess === correctSynonym) {
                    // Award bonus points for correct word completion
                    updateScore(currentSynonymLetters.length * 5); // Example: 5 bonus points per letter
                    gameScreen.classList.add('confetti-glow');
                    setTimeout(() => {
                        gameScreen.classList.remove('confetti-glow');
                    }, 1000);

                    speak("Excellent! You found the synonym!");
                    clearFallingLetters(); // Stop all letters from falling for a clean transition
                    setTimeout(nextRound, 1500);
                } else {
                    // If all filled but incorrect, provide feedback (optional: reset)
                    speak("Not quite right, try again!");
                    // Optional: You could add a mechanism to reset the dropped letters here
                    // For now, it stays as is, allowing user to correct
                }
            }
        }

        // --- Game Flow Functions ---

        /**
         * Initializes game state and shows welcome screen.
         */
        function initGame() {
            gameScreen.style.display = 'none';
            welcomeScreen.style.display = 'flex';
            currentRound = 0;
            score = 0;
            timeLeft = 300;
            updateScore(0);
            timerDisplay.textContent = formatTime(timeLeft);
            roundDisplay.textContent = `${currentRound}/20`;
            if (timerInterval) clearInterval(timerInterval);
            clearFallingLetters(); // Ensure a clean state for falling letters
            hideGameMessage();
        }

        /**
         * Starts the game.
         */
        function startGame() {
            welcomeScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
            currentRound = 1;
            roundDisplay.textContent = `${currentRound}/20`;
            startTimer();
            startRound();
        }

        /**
         * Starts the game timer.
         */
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = formatTime(timeLeft);
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame("Time's Up!", `Your final score is: ${score}`);
                }
            }, 1000);
        }

        let randomHintIndex = -1;

        /**
         * Sets up a new round.
         */
        function startRound() {
            dropZoneContainer.innerHTML = ''; // Clear previous drop zones

            currentWordIndex = Math.floor(Math.random() * wordData.length);
            const { base, synonym } = wordData[currentWordIndex];

            baseWordDisplay.textContent = base;
            currentSynonymLetters = synonym.toUpperCase().split('');
            droppedLetters = Array(currentSynonymLetters.length).fill('');
            droppedLetterOriginalIds = Array(currentSynonymLetters.length).fill('');

            // Determine and apply hint
            randomHintIndex = Math.floor(Math.random() * currentSynonymLetters.length);
            const hintLetter = currentSynonymLetters[randomHintIndex];
            droppedLetters[randomHintIndex] = hintLetter; // Pre-fill in state

            // Create drop zones
            currentSynonymLetters.forEach((char, index) => {
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone');
                dropZone.dataset.index = index;

                if (index === randomHintIndex) {
                    dropZone.textContent = hintLetter;
                    dropZone.classList.add('correct', 'hint-cell');
                    // Prevent hint cells from being draggable targets
                } else {
                    dropZone.addEventListener('dragover', handleDragOver);
                    dropZone.addEventListener('dragleave', handleDragLeave);
                    dropZone.addEventListener('drop', handleDrop);
                }
                dropZoneContainer.appendChild(dropZone);
            });

            // Recalculate FALL_SPEED_PX_PER_SEC based on current fall area height
            // This ensures letters always fall from top to bottom of the visible fall area in 16s
            const currentFallAreaHeight = letterFallColumns[0].offsetHeight;
            FALL_SPEED_PX_PER_SEC = (currentFallAreaHeight + LETTER_VISUAL_HEIGHT * 2) / 16;


            startLetterSpawningManager(); // Start the letter spawning and animation
        }

        /**
         * Advances to the next round.
         */
        function nextRound() {
            currentRound++;
            if (currentRound > 20) {
                endGame("Game Over!", `You completed all rounds! Your final score is: ${score}`);
            } else {
                roundDisplay.textContent = `${currentRound}/20`;
                startRound();
            }
        }

        /**
         * Skips the current word.
         */
        function skipWord() {
            updateScore(-20);
            speak("Word skipped.");
            clearFallingLetters();
            setTimeout(nextRound, 500);
        }

        /**
         * Ends the game and shows modal.
         * @param {string} title - Modal title.
         * @param {string} message - Modal message.
         */
        function endGame(title, message) {
            clearInterval(timerInterval);
            clearFallingLetters(); // Stop all animations
            showGameMessage(title, message);
        }

        /**
         * Displays the game message modal.
         */
        function showGameMessage(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            gameMessageModal.style.display = 'flex';
        }

        /**
         * Hides the game message modal.
         */
        function hideGameMessage() {
            gameMessageModal.style.display = 'none';
        }

        // --- Event Listeners ---
        beginLearningButton.addEventListener('click', startGame);
        nextButton.addEventListener('click', nextRound);
        skipButton.addEventListener('click', skipWord);
        modalCloseButton.addEventListener('click', initGame);

        // Initial setup on DOM load
        document.addEventListener('DOMContentLoaded', initGame);
        // Also recalculate fall speed on window resize to maintain consistent fall duration
        window.addEventListener('resize', () => {
            const currentFallAreaHeight = letterFallColumns[0].offsetHeight;
            FALL_SPEED_PX_PER_SEC = (currentFallAreaHeight + LETTER_VISUAL_HEIGHT * 2) / 16;
        });
    </script>
</body>
</html>
