<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Jumble</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* General Setup */
        :root {
            --header-height: 8vh;
            --footer-height: 5vh;
            --controls-min-height: 8vh;
            --grid-gap: 8px;
            --primary-color: #4a90e2;
            --light-gray: #f0f2f5;
            --dark-gray: #333;
            --background-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: var(--background-gradient);
            color: var(--dark-gray);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Screen Management */
        .screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            position: absolute;
            top: 0;
            left: 0;
        }

        .screen.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            z-index: -1;
        }

        /* Header and Footer */
        header, footer {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
            flex-shrink: 0;
        }

        header {
            height: var(--header-height);
            text-align: center;
            padding: 0 1rem;
        }

        header h1 {
            font-size: clamp(0.9rem, 2.2vh, 1.2rem);
            font-weight: 600;
        }
        
        #home-screen-subheader {
             font-size: clamp(0.8rem, 2vh, 1rem);
             color: #555;
             margin-top: 1vh;
        }

        footer {
            height: var(--footer-height);
            font-size: clamp(0.7rem, 1.5vh, 0.9rem);
            color: #666;
            border-top: 1px solid #ddd;
        }

        /* Help Screen */
        #help-screen .content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.2rem;
            padding: 20px;
            height: calc(100vh - var(--header-height) - var(--footer-height));
            text-align: center;
        }

        .help-title { font-size: clamp(1.1rem, 2.6vh, 1.4rem); font-weight: 700; }
        .help-byline { font-size: clamp(0.9rem, 2vh, 1.1rem); color: #555; }
        .help-desc { max-width: 70ch; color: #444; line-height: 1.6; }
        .primary-button {
            background: var(--primary-color);
            color: #fff;
            border: none;
            padding: 12px 22px;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.15s ease, background-color 0.2s ease;
        }
        .primary-button:hover { background-color: #357bd8; transform: translateY(-1px); }

        /* Screen 1: Emoji Selection */
        #home-screen .content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            height: calc(100vh - var(--header-height) - var(--footer-height));
        }

        .emoji-grid-6x6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: clamp(8px, 2vmin, 20px);
            width: 100%;
            height: 75vh;
            max-width: 95vmin;
            max-height: 95vmin;
            aspect-ratio: 1 / 1;
        }

        .emoji-cell {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 7vmin, 4rem);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .emoji-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }

        /* Screen 2: Game Screen */
        #game-screen {
            justify-content: space-between;
        }

        #game-screen .content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 1rem;
            overflow: hidden;
        }

        .grid-4x4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--grid-gap);
            width: 100%;
            height: auto;
            max-width: 85vmin;
            max-height: 85vmin;
            aspect-ratio: 1 / 1;
            background: rgba(0, 0, 0, 0.1);
            padding: var(--grid-gap);
            border-radius: 16px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .tile-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .tile-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-color: var(--light-gray);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .tile-canvas.selected {
            transform: scale(0.95);
            box-shadow: 0 0 0 4px var(--primary-color), 0 0 20px var(--primary-color);
            z-index: 5;
        }

        .tile-canvas.correct, .tile-canvas.locked {
            box-shadow: inset 0 0 0 3px #68d391;
            background-color: #c6f6d5;
            cursor: not-allowed;
        }

        /* Game Controls */
        .game-controls {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            width: 100%;
            min-height: var(--controls-min-height);
        }

        .control-item, .control-button {
            background: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            font-size: clamp(0.8rem, 2vh, 1.1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-button {
            cursor: pointer;
            border: none;
            transition: background-color 0.2s, opacity 0.2s;
        }

        .control-button:hover:not(:disabled) {
            background-color: #eef;
        }

        .control-button:disabled {
            background-color: #e2e8f0;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .control-item span {
            color: var(--primary-color);
            min-width: 30px;
            text-align: left;
        }

        /* Modal Dialog */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .modal-content p {
            font-size: 1.2rem;
            color: #555;
            margin-bottom: 25px;
        }

        .modal-button {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            background-color: var(--primary-color);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .modal-button:hover {
            background-color: #357bd8;
        }
        
        /* Confetti Animation */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            top: -20px;
            width: 10px;
            height: 10px;
            opacity: 0.8;
            animation: fall 5s linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(105vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Glow effect for landed tiles */
        @keyframes glowPulse {
            0% { box-shadow: 0 0 0 0 rgba(74,144,226,0.6), 0 0 0 0 rgba(74,144,226,0.25); }
            50% { box-shadow: 0 0 0 6px rgba(74,144,226,0.35), 0 0 18px 6px rgba(74,144,226,0.25); }
            100% { box-shadow: 0 0 0 0 rgba(74,144,226,0.0), 0 0 0 0 rgba(74,144,226,0.0); }
        }
        .glow-pulse { animation: glowPulse 0.25s ease-in-out 5; }
    </style>
</head>
<body>

    <canvas id="emoji-source-canvas" width="600" height="600" style="display:none;"></canvas>
    <div id="confetti-container"></div>

    <div id="help-screen" class="screen">
        <header>
            <h1>Emoji Jumble — Help</h1>
        </header>
        <main class="content">
            <div class="help-title">Unscramble the emoji, tile by tile</div>
            <div class="help-byline">A quick, joyful brain teaser for all ages</div>
            <p class="help-desc">Pick any emoji you like. We’ll slice it into a neat 4×4 grid and shuffle the pieces. Tap two tiles to swap them and reconstruct the original emoji. Use hints if you’re stuck—fewer moves, higher score!</p>
            <button id="start-joining" class="primary-button">Start Joining</button>
        </main>
        <footer>
            <p>copyright beyond dictionary 2025</p>
        </footer>
    </div>

    <div id="home-screen" class="screen hidden">
        <header>
            <h1>Jumble back the emoji to its own shape</h1>
        </header>
        <main class="content">
            <h2 id="home-screen-subheader">Select an emoji to start the game</h2>
            <div class="emoji-grid-6x6" id="emoji-selection-grid"></div>
        </main>
        <footer>
            <p>copyright beyond dictionary 2025</p>
        </footer>
    </div>

    <div id="game-screen" class="screen hidden">
        <main class="content">
            <div class="grid-4x4" id="puzzle-grid"></div>
        </main>
         <div class="game-controls">
            <div class="control-item">Moves: <span id="moves-display">0</span></div>
            <div class="control-item">Score: <span id="score-display">0</span></div>
            <div class="control-item">Points: <span id="points-display">0</span></div>
            <button class="control-button" id="hint-button">💡 Hint (<span id="hint-count">2</span>)</button>
            <button class="control-button" id="voice-toggle">🔊 Voice On</button>
            <button class="control-button" id="back-to-home">🏠 Home</button>
        </div>
    </div>
    
    <div id="game-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <button id="modal-close-button" class="modal-button">OK</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const homeScreen = document.getElementById('home-screen');
        const gameScreen = document.getElementById('game-screen');
        const emojiSelectionGrid = document.getElementById('emoji-selection-grid');
        const puzzleGrid = document.getElementById('puzzle-grid');
        const sourceCanvas = document.getElementById('emoji-source-canvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const backToHomeBtn = document.getElementById('back-to-home');
        const voiceToggleBtn = document.getElementById('voice-toggle');
        const hintButton = document.getElementById('hint-button');
        const hintCountDisplay = document.getElementById('hint-count');
        const helpScreen = document.getElementById('help-screen');
        const startJoiningBtn = document.getElementById('start-joining');
        
        // --- Game State ---
        const EMOJI_LIST = [
            '😀', '😂', '😍', '🤔', '😎', '😭', '😡', '🤯', '🥳', '🥺', '😇', '🤠',
            '👽', '👻', '🤖', '👾', '🦁', '🐯', '🦊', '🦄', '🐸', '🐵', '🐔', '🐧',
            '🦋', '🐌', '🐞', '🐢', '🐳', '🐠', '🐙', '🦀', '🍕', '🍔', '🍟', '🍩'
        ];
        const GRID_SIZE = 4;
        const TILE_COUNT = GRID_SIZE * GRID_SIZE;

        let selectedEmoji = '😀';
        let tileOrder = [];
        let lockedTiles = [];
        let selectedTileIndex = null;
        let moveCount = 0;
        let score = 0;
        let points = 0;
        let hintCount = 2;
        let voiceOn = true;
        let gameWon = false;
        let startTimeMs = 0;

        // --- Functions ---
        
        function launchConfetti() {
            const container = document.getElementById('confetti-container');
            if (!container) return;
            container.innerHTML = '';
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800'];

            for (let i = 0; i < 150; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.width = Math.random() * 8 + 5 + 'px';
                confetti.style.height = confetti.style.width;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                container.appendChild(confetti);
            }
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => {
                if(s.id === screenId) s.classList.remove('hidden');
                else s.classList.add('hidden');
            });
        }

        function populateEmojiGrid() {
            emojiSelectionGrid.innerHTML = '';
            for (let i = 0; i < 36; i++) {
                const cell = document.createElement('div');
                cell.className = 'emoji-cell';
                cell.textContent = EMOJI_LIST[i % EMOJI_LIST.length];
                cell.addEventListener('click', () => selectEmoji(cell.textContent));
                emojiSelectionGrid.appendChild(cell);
            }
        }
        
        function selectEmoji(emoji) {
            selectedEmoji = emoji;
            homeScreen.style.opacity = '0';
            setTimeout(() => {
                showScreen('game-screen');
                startGame();
            }, 500);
        }

        function speak(text) {
            if (voiceOn && window.speechSynthesis) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.1;
                speechSynthesis.speak(utterance);
            }
        }

        function indexToRowCol(index) {
            return { r: Math.floor(index / GRID_SIZE), c: index % GRID_SIZE };
        }

        function chebyshevDistance(aIndex, bIndex) {
            const a = indexToRowCol(aIndex);
            const b = indexToRowCol(bIndex);
            return Math.max(Math.abs(a.r - b.r), Math.abs(a.c - b.c));
        }

        function placementFeedback(newIndex, tileId) {
            if (newIndex === tileId) return "Right placement";
            const d = chebyshevDistance(newIndex, tileId);
            if (d === 1) return "Close by";
            return "Going far";
        }

        function toggleVoice() {
            voiceOn = !voiceOn;
            voiceToggleBtn.textContent = voiceOn ? "🔊 Voice On" : "🔇 Voice Off";
            speak(voiceOn ? "Voice enabled" : "Voice disabled");
        }

        function updateStats() {
            document.getElementById('moves-display').textContent = moveCount;
            document.getElementById('score-display').textContent = score;
            document.getElementById('points-display').textContent = points;
            hintCountDisplay.textContent = hintCount;
            checkHintButtonState();
        }

        function checkHintButtonState() {
            const correctTiles = tileOrder.filter((tileId, index) => tileId === index).length;
            hintButton.disabled = gameWon || hintCount <= 0 || correctTiles >= 11;
        }

        function isGameSolved() {
            return tileOrder.every((tileId, index) => tileId === index);
        }
        
        function showModal(title, message) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            const modal = document.getElementById('game-modal');
            modal.classList.add('visible');
            const closeButton = document.getElementById('modal-close-button');
            closeButton.addEventListener('click', () => modal.classList.remove('visible'), { once: true });
        }
        
        function useHint() {
            if (hintButton.disabled) return;
            
            hintCount--;
            points -= 25;

            // Find two adjacent, incorrect, unlocked tiles
            let found = false;
            for (let i = 0; i < TILE_COUNT && !found; i++) {
                const isCorrect = tileOrder[i] === i;
                const isLocked = lockedTiles.includes(i);
                
                // Find first incorrect tile
                if (!isCorrect && !isLocked) {
                    const firstIncorrectIndex = i;
                    const correctTileIdForThisSpot = firstIncorrectIndex;
                    const currentIndexOfCorrectTile = tileOrder.indexOf(correctTileIdForThisSpot);
                    
                    // Check if the tile that SHOULD be here is not itself locked
                    if(!lockedTiles.includes(currentIndexOfCorrectTile)) {
                         // Swap the correct tile into place
                        [tileOrder[firstIncorrectIndex], tileOrder[currentIndexOfCorrectTile]] = [tileOrder[currentIndexOfCorrectTile], tileOrder[firstIncorrectIndex]];
                        
                        lockedTiles.push(firstIncorrectIndex); // Lock the now-correct tile
                        found = true;
                    }
                }
            }
            speak("Hint applied.");
            drawPuzzleGrid();
        }

        function drawPuzzleGrid() {
            sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
            sourceCtx.font = "500px sans-serif";
            sourceCtx.textAlign = "center";
            sourceCtx.textBaseline = "middle";
            sourceCtx.fillText(selectedEmoji, sourceCanvas.width / 2, sourceCanvas.height / 2);

            puzzleGrid.innerHTML = "";
            const TILE_SIZE = sourceCanvas.width / GRID_SIZE;

            tileOrder.forEach((tileId, cellIndex) => {
                const container = document.createElement("div");
                container.className = "tile-container";

                const tileCanvas = document.createElement("canvas");
                tileCanvas.className = 'tile-canvas';
                tileCanvas.width = tileCanvas.height = TILE_SIZE;
                tileCanvas.dataset.index = cellIndex; 
                tileCanvas.dataset.tileId = tileId;     

                const tileCtx = tileCanvas.getContext("2d");
                const sx = (tileId % GRID_SIZE) * TILE_SIZE;
                const sy = Math.floor(tileId / GRID_SIZE) * TILE_SIZE;
                tileCtx.drawImage(sourceCanvas, sx, sy, TILE_SIZE, TILE_SIZE, 0, 0, TILE_SIZE, TILE_SIZE);

                if (lockedTiles.includes(cellIndex)) {
                    tileCanvas.classList.add("locked");
                } else if (parseInt(tileId) === cellIndex) {
                    tileCanvas.classList.add("correct");
                }
                if (cellIndex === selectedTileIndex) {
                    tileCanvas.classList.add("selected");
                }

                tileCanvas.addEventListener('click', () => handleTileClick(cellIndex));
                
                container.appendChild(tileCanvas);
                puzzleGrid.appendChild(container);
            });

            updateStats();

            if (!gameWon && isGameSolved()) {
                gameWon = true;
                points += 500;
                score = points;
                updateStats(); 
                launchConfetti();
                
                setTimeout(() => {
                    const elapsedSec = Math.max(1, Math.round((Date.now() - startTimeMs) / 1000));
                    const winMessage = `You won! Focus and persistence paid off. You completed the emoji game in ${elapsedSec} seconds and ${moveCount} moves. Keep shining.`;
                    speak(winMessage);
                    showModal("🎉 You Won! 🎉", winMessage);
                }, 1000);
            }
        }

        function handleTileClick(index) {
            if (gameWon || lockedTiles.includes(index)) return;

            if (selectedTileIndex === null) {
                selectedTileIndex = index;
                drawPuzzleGrid();
            } else if (selectedTileIndex === index) {
                selectedTileIndex = null;
                drawPuzzleGrid();
            } else {
                 if (lockedTiles.includes(selectedTileIndex)) {
                    selectedTileIndex = null;
                    drawPuzzleGrid();
                    return;
                }
                const from = selectedTileIndex;
                const to = index;
                const movedTileIdA = tileOrder[from];
                const movedTileIdB = tileOrder[to];
                
                setTimeout(() => {
                    [tileOrder[from], tileOrder[to]] = [tileOrder[to], tileOrder[from]];
                    moveCount++;
                    points = Math.max(0, 1000 - (moveCount * 10));
                    score = points;
                    selectedTileIndex = null;
                    drawPuzzleGrid();
                    // Evaluate both swapped tiles
                    const landedA = (to === movedTileIdA);
                    const landedB = (from === movedTileIdB);
                    const anyRight = landedA || landedB;
                    const anyClose = !anyRight && (
                        chebyshevDistance(to, movedTileIdA) === 1 ||
                        chebyshevDistance(from, movedTileIdB) === 1
                    );
                    // Visual glow for landed tiles (pulse 5 times)
                    if (landedA) {
                        const tileCanvasA = puzzleGrid.querySelector(`canvas[data-index='${to}']`);
                        if (tileCanvasA) tileCanvasA.classList.add('glow-pulse');
                        setTimeout(()=>{ if (tileCanvasA) tileCanvasA.classList.remove('glow-pulse'); }, 1250);
                    }
                    if (landedB) {
                        const tileCanvasB = puzzleGrid.querySelector(`canvas[data-index='${from}']`);
                        if (tileCanvasB) tileCanvasB.classList.add('glow-pulse');
                        setTimeout(()=>{ if (tileCanvasB) tileCanvasB.classList.remove('glow-pulse'); }, 1250);
                    }

                    // Voice feedback
                    if (landedA && landedB) {
                        speak("Knockout. Two parts are fixed.");
                    } else if (anyRight) {
                        speak("Right placement");
                    } else if (anyClose) {
                        speak("Close by");
                    } else {
                        speak("Going far");
                    }
                }, 200);
            }
        }
        
        function startGame() {
            gameWon = false;
            moveCount = 0;
            score = 0;
            points = 1000;
            hintCount = 2;
            lockedTiles = [];
            selectedTileIndex = null;
            startTimeMs = Date.now();
            tileOrder = [...Array(TILE_COUNT).keys()].sort(() => Math.random() - 0.5);
            
            let attempts = 0;
            while (isGameSolved() && attempts < 10) {
                 tileOrder = [...Array(TILE_COUNT).keys()].sort(() => Math.random() - 0.5);
                 attempts++;
            }
            drawPuzzleGrid();
        }
        
        function goHome() {
            homeScreen.style.opacity = '1';
            showScreen('home-screen');
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            populateEmojiGrid();
            showScreen('help-screen');
        });
        backToHomeBtn.addEventListener('click', goHome);
        voiceToggleBtn.addEventListener('click', toggleVoice);
        hintButton.addEventListener('click', useHint);
        if (startJoiningBtn) startJoiningBtn.addEventListener('click', ()=> showScreen('home-screen'));

    </script>
</body>
</html>
